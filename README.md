# schema-generator

**schema-generator** generates JSON schema components from XML Schema that support binding to Java classes .  

The JSON schema components are generated by processing four products that originate from XML Schema. 

Two are produced by [xml-schema-convertor](../xml-schema-convertor/README.md): 

  1. JavaScript modules and 
  2. intermediary JSON Schema.  
  
The other two are produced by [xml-schema-content-extractor](../xml-schema-content-extractor/README.md): 

  3. data component documentation
  4. data component facets

```
  .------------.
  | JavaScript |
  |   modules  |`-------->.  
  '------------'           |
  .--------------.         |
  | intermediary |         |
  | JSON Schema  |`------->:
  '--------------'         |       .+-+-+-+-+-+.
  .----------------.       :---->  + schema-   +
  | data component |       |       + generator +
  | documentation  |`----->:       '+-+-+-+-+-+'     .-------------.
  '----------------'       |                `----->  | JSON schema |
  .----------------.       |                         | components  |
  | data component |       |                         '-------------'
  |     facets     |`---->'
  '----------------'

```
## What-You-Start-With-Is-What-You-Get (WYSWIWYG)
Since XML Schema is the source, **schema-generator** generates JSON schema with patterns and characteristics derived from the source XML Schema.  Therefore, if the source XML Schema is described with a deep data model, the JSON schema will also have a deep data model.  And, if the source XML Schema is well documented and constrained, the generated JSON schema will have these similar characteristics.

# Differentiated Capabilities
**schema-generator** stands out from the hand-full of products that convert XML Schema to JSON Schema.  The differentiated capabilities are support for:

  * Jackson-based jsonschema2pojo Java binding
  * XML Schema substitution and abstract elements
  * XML Schema documentation
  * XML Schema simple-type validation facets
  * configurable global validation facets

## Jackson-based jsonschema2pojo Java Binding
**schema-generator** is specifically tuned to support Jackson-based *jsonschema2pojo*.  [Jackson](https://github.com/FasterXML/jackson) is a prominant JSON library of modules for Java.  And, [jsonschema2pojo](https://github.com/joelittlejohn/jsonschema2pojo) is a popular Java binder for JSON schema.  

More about *jsonschema2pojo* is that it implements the *Jackson* module  [jackson-module-jsonSchema](https://github.com/FasterXML/jackson-module-jsonSchema), which supports [JSON Schema Version 3](https://tools.ietf.org/html/draft-zyp-json-schema-03).  This is an issue because [JSON Schema Version 4](https://tools.ietf.org/html/draft-fge-json-schema-validation-00) is currently more popular in other languages than *JSON Schema Version 3*. 

**schema-generator** overcomes the *JSON Schema Version 3* by converting *JSON Schema Version 4* schema generated by [JSONIX](https://github.com/highsource/jsonix) to *JSON Schema Version 3* schema.

For more specific information about the missing support for *JSON Schema Version 4* `oneOf`, `anyOf` and `allOf` keywords, see [Generating a POJO using oneOf, anyOf or allOf with constraints · Issue #392 · joelittlejohn/jsonschema2pojo](https://github.com/joelittlejohn/jsonschema2pojo/issues/392). 

## XML Schema Substitution And Abstract Elements

## XML Schema Documentation

## XML Schema Simple-Type Validation Facets

## Configurable Global Validation Facets

## JSONIX

  * Jsonix is based on JAXB/XJC.  XJC uses XSOM to process XML schemas (https://github.com/highsource/jsonix/issues/33)

### Jsonix Caveats
The following Jsonix caveats that the Schema Generator is intended to resolve.

  * xs:pattern is not supported and the expressions are not compatible
    * XML Schema regular expressions are not compatible with JavaScript/ECMAScript regular expressions
      * http://stackoverflow.com/questions/33482031/are-xml-schema-regular-expressions-compatible-to-javascript-ecmascript-regular-e
  * xs:annotation and simple type facets, e.g., as xs:pattern, xs:length, xs:enumeration, are not supported
    * JAXB may be the reason since simple type facets are ignored
      * https://jaxb.java.net/guide/Generating_Schema_that_you_want.html
      * https://java.net/jira/browse/JAXB-917
    * A simple extension to JAXB RI is available but Java developers have disappeared:
      * https://github.com/whummer/jaxb-facets)
    *   length, enumerations



#JSON Schema Generation
Several schema file components are produced to represent general and specific concepts and properties.  They are associated to each other by relative file-path value in a '$ref' property.  These associations compose larger representations for general concepts.  In other words, general concepts are described by specific concepts and properties that are assocatied to each other by file references.  A de-referenced JSON schema file contains all the representations that describe a general concept.

#JSON Schema Mappings

  ```
  "id": anyOf[].elementName.namespaceURI + lowerFirstCharacter(anyOf.elementName.localPart)
  "title": lowerFirstCharacter(anyOf.elementName.localPart)
  "type": anyOf.elementName.type
  "description": ""
  "version": "0.1.0"
  "javaType": replace(trim(anyOf.elementName.namespaceURI, "http:// https://"), "/", "_") + replace(anyOf.elementName.localPart), "/", "_")
  "required": anyOf.properties.value.$ref.required
  ```
#Algorithmic Design Entities

##anyOf
JSON schema objects are described by the "anyOf" object.

  ```
  "anyOf" :[
    {
      "elementName" / "attributeName" : {}
      "type" : ""
      "properties" : {
        "value" : {
          "$ref" : ""  
        }
      }
      
    }
  ]
  ```
An elementName object generates a JSON schema object.  

An attributeName object adds a property to a local JSON schema object.

###$ref
A "$ref" object points to a definition object.  A definition is isometric to an XML type.  It contains the JSON schema object's structural properties and constraints.

The "$ref" object may point to a local or remote definition object.  

The following example is a remote reference:

```
"$ref":"http://release.niem.gov/niem/niem-core/3.0/#/definitions/TextType"
```
A remote reference is processed to obtain the schema file that contains the definition object.  The schema file is identified by a match of the namespace part to a pre-configured mapping.

##definitions
JSON schema object's structural properties and constraints are defined by a "definitions" object.

  ```
  "definitions" : {
    <object-type> : {
      {} / allOf" : [
        {
          "properties" : {
            <object> : {
              "title" : "",
              "elementName" / "attributeName" : {}
            }
          }
        }
      ]
    }
  }

  ```

#Conventions

  * namespace format: http://mcsc.usmc.mil/mc2sa/tsoa/soi/[domain-object]/[version] 
    * namespace is a URL that contains only lower-case letters
    * a hyphen seperates nouns, adjectives and other modifiers
    * example: `http://mcsc.usmc.mil/mc2sa/tsoa/soi/ObservedPlatformSystem/2.0`
  * schema file name matches [domain-object]
    * upper-camel-case starts and seperates nouns, adjectives and other modifiers
    * example: `ObservedPlatformSystem.xsd`
  * namespace prefix is represented by first letter of the system, service, domain object namespace parts
    * example: `xmlns:tst="http://mcsc.usmc.mil/mc2sa/tsoa/soi/track/2.0/`



#workflow (no longer applicable)
Every 'anyOf' and 'definition' referenced by an anyOf component gets a schema file generated.  

#To-Do
- [x] narrow breadth of components converted from XML Schema to only those referenced
- [x] implement relative path to external components
- [x] keep component capitalization
- [x] remove default schema require declarative that is empty
- [x] capture enumeration values
- [X] implement enumeration values
- [x] capture facets (https://github.com/gmoyanollc/xml-schema-content-extractor)
- [X] implement facets
- [x] capture component documentation (https://github.com/gmoyanollc/xml-schema-content-extractor)
- [x] implement component documentation
- [x] capture substitution components
- [ ] re-implement substitution handler
- [ ] re-implement default facet handler
- [ ] ignore abstract container component
- [ ] ignore abstracts like augmentation point container, define and reference components or substitution components
        * augmentation point objects are listed in type definitions
        * the assocation between an augmentation point object and its containing <elements> is described in jsonix js module.
          ** descendent component may be identified by a substitutionHead property that associates it to an augmentation point object
            - [x] populate a lookup table containing substitutionHeads and their substitutions
            - [x] lookup substitutions for substitutionHeads and generate
- [x] define substition components in augmentation point type
- [x] allOf reference to a definition should define only the properties of the definition.  The definition object should be ignored.
- [x] include base definition in derived component, e.g., mo:Degree360Type --> nc:Degree360Type, Type --> SimpleType
- [x] generate schema files recursively or remove filter for JSONIX compiler.  The schema file for certain definition properties is never generated because the property is locally referenced by a definition but not defined in the local JSONIX schema file.  This may be attributeable to filtered generation of JSONIX artifacts. [Example]("http://release.niem.gov/niem/niem-core/3.0/#SystemName")  Another case is a definition not referenced by a local 'anyOf' component.
- [x] refactor global scope to include constants in generator object
  [X] halt execution when file not found
  [ ] $id needs to conform to json schema [spec](https://tools.ietf.org/html/draft-handrews-json-schema-00#section-9.2)
  [ ] JSON-LD context builder
  [ ] enumeration Code List builder
  [ ] custom component representation, e.g., add a regex pattern 

- - -

[George Moyano](https://onename.com/gmoyano)
@github/gmoyanollc
version 0.5.9